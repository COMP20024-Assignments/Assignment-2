
package CyberdyneSystems.generic;

import aiproj.slider.Move;

/** COMP30024 Artificial Intelligence
 Board class
 George Juliff - 624946
 Thomas Miles - 626263

 Board class for use by agents, memory usage is minimised by using single bytes as much as possible
 */
public class Board {

    public final static byte O = 0; // Open tile
    private final static byte B = 1; // Blocked tile
    public final static byte H = 2; // H player tile
    public final static byte V = 3; // V player tile

    private final static byte MIN_SIZE = 3;
    private final static byte MAX_SIZE = 127; // maximum possible value a byte can be

    public byte[][] layout;
    private static byte SIZE;  // hehehe get it.. byte size..


    /**
     * Constructor used in init that reads a string layout layout
     *
     * @param dimension   layout size
     * @param boardLayout string generated by referee passed through
     * @param me          the agent that owns the layout, passed in so the layout can set the pieces from the layout
     * @param enemy       enemy agent
     */
    Board(int dimension, String boardLayout, Agent me, Agent enemy) {

        layout = new byte[dimension][dimension];
        SIZE = (byte) dimension;

        if (dimension < MIN_SIZE || dimension > MAX_SIZE) {
            System.out.println("Invalid layout size, terminating");
            System.exit(1);
        }
        if (me.player == H) {
            fillBoard(boardLayout, me, enemy);
        } else {
            fillBoard(boardLayout, enemy, me);
        }

    }

    /**
     * Constructor for creating layout from a given byte array
     *
     * @param copy array to be copied
     */
    Board(byte[][] copy) {
        layout = new byte[SIZE][SIZE];
        for (int i=0; i<SIZE; i++) {
            for (int j=0; j<SIZE; j++) {
                layout[i][j] = copy[i][j];
            }
        }
    }


    /**
     * Checks if a position can be moved to
     *
     * @param x coordinate
     * @param y coordinate
     * @return true if the requested coordinate is within the array bounds and is an open tile
     */
    public boolean canMoveTo(int x, int y, byte player) {

        return (x == SIZE && player == H) || (y == SIZE && player == V) || (x < SIZE && y < SIZE && x >=0 && y >= 0 && layout[x][y] == O);
    }


    public static byte getSize() {
        return SIZE;
    }


    private void fillBoard(String boardLayout, Agent h, Agent v) {
        byte[] piece;
        int k = 0;
        for (int j = SIZE - 1; j >= 0; j--) {
            for (int i = 0; i < SIZE; i++) {
                boolean registered = false;
                while ((k < boardLayout.length()) && !registered) {
                    switch (boardLayout.charAt(k)) {
                        case ('B'):
                            registered = true;
                            layout[i][j] = B;
                            break;

                        case ('V'):
                            registered = true;
                            piece = new byte[2];
                            piece[Agent.i] = (byte) i;
                            piece[Agent.j] = (byte) j;

                            v.pieces.add(piece);
                            layout[i][j] = V;
                            break;

                        case ('H'):
                            registered = true;

                            piece = new byte[2];
                            piece[Agent.i] = (byte) i;
                            piece[Agent.j] = (byte) j;
                            h.pieces.add(piece);

                            layout[i][j] = H;
                            break;

                        case ('+'):
                            registered = true;
                            layout[i][j] = O;
                            break;
                        default:
                            registered = false;
                    }
                    //     System.out.println("char: " +  boardLayout.charAt(k) +"\nregistered: "+registered+"\ni: "+i+"\nj: "+j+"\n\n");
                    k++;
                }
            }
        }
    }

    /**
     * Updates the boards state given a Move
     *
     * @param move       move object
     * @param playerType byte value H or V (2/3)
     */
    public void update(Move move, byte playerType) {

        switch (move.d) {

            case UP:

                //piece can move or went off the layout
                if ((canMoveTo((byte)move.i, (byte)move.j + 1, playerType))) {
                    layout[move.i][move.j] = O;

                    // if it didn't move off, update the tile it moved to
                    if (move.j + 1 < SIZE) {
                        layout[move.i][move.j + 1] = playerType;
                    }
                    // move was illegal, this shouldn't happen (chance this to an exception)
                } else {
     //               System.out.println("ERROR: Illegal move");
                    // System.exit(1);
                }
                break;

            case DOWN:

                ///piece can move
                if ((canMoveTo((byte)move.i, (byte)move.j - 1, playerType))) {
                    layout[move.i][move.j] = O;
                    layout[move.i][move.j - 1] = playerType;

                    // move was illegal, this shouldn't happen (chance this to an exception)
                } else {
     //               System.out.println("ERROR: Illegal move");
                    //  System.exit(1);
                }
                break;

            case LEFT:

                ///piece can move
                if ((canMoveTo((byte)move.i - 1, (byte)move.j, playerType))) {
                    layout[move.i][move.j] = O;
                    layout[move.i - 1][move.j] = playerType;

                    // move was illegal, this shouldn't happen (chance this to an exception)
                } else {
     //               System.out.println("ERROR: Illegal move");
                    //   System.exit(1);
                }
                break;

            case RIGHT:

                //piece can move or went off the layout
                if ((canMoveTo((byte)move.i + 1, (byte)move.j, playerType))) {
                    layout[move.i][move.j] = O;

                    // if it didn't move off, update the tile it moved to
                    if (move.i + 1 < SIZE) {
                        layout[move.i + 1][move.j] = playerType;
                    }
                    // move was illegal, this shouldn't happen (chance this to an exception)
                } else {
       //             System.out.println("ERROR: Illegal move" );
                    //   System.exit(1);
                }
                break;
        }
    }
    public void printLayout() {
        for (int j=SIZE-1; j>=0;j--) {
            for (int i=0; i<SIZE; i++) {
                System.out.print(layout[i][j]+" ");
            }
            System.out.println();
        }
        System.out.println();
    }
}
