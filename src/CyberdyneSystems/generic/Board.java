
package CyberdyneSystems.generic;

import aiproj.slider.Move;

/** COMP30024 Artificial Intelligence
 Board class
 George Juliff - 624946
 Thomas Miles - 626263

 Board class for use by agents, memory usage is minimised by using single bytes as much as possible
 */
public class Board {

    public final static byte O = 0; // Open tile
    final static byte B = 1; // Blocked tile
    public final static byte H = 2; // H player tile
    public final static byte V = 3; // V player tile
    final static byte MIN_SIZE = 3;
    final static byte MAX_SIZE = 127; // maximum possible value a byte can be

    public byte[][] board;
    private byte SIZE;  // hehehe get it.. byte size..


    /**
     * Constructor used in init that reads a string board layout
     *
     * @param dimension   board size
     * @param boardLayout string generated by referee passed through
     * @param me          the agent that owns the board, passed in so the board can set the pieces from the layout
     * @param enemy       enemy agent
     */
    public Board(int dimension, String boardLayout, Agent me, Agent enemy) {

        board = new byte[dimension][dimension];

        if (dimension < MIN_SIZE || dimension > MAX_SIZE) {
            System.out.println("Invalid board size, terminating");
            System.exit(1);
        }
        if (me.player == H) {
            fillBoard(boardLayout, me, enemy);
        } else {
            fillBoard(boardLayout, enemy, me);
        }
        SIZE = (byte) dimension;
    }

    /**
     * Constructor for creating board from a given byte array
     *
     * @param copy array to be copied
     * @param size size of array
     */
    public Board(byte[][] copy, byte size) {
        board = new byte[size][size];
        board = copy.clone();
    }




    /**
     * Checks if a position can be moved to
     *
     * @param x coordinate
     * @param y coordinate
     * @return true if the requested coordinate is within the array bounds and is an open tile
     */
    public boolean canMoveTo(int x, int y) {
        // if moving off the board or moving to an open tile
        return x == SIZE || y == SIZE || (x >= 0 && y >= 0 && board[x][y] == O);
    }


    public byte getSize() {
        return SIZE;
    }


    public void fillBoard(String boardLayout, Agent h, Agent v) {

        int k = 0;
        for (int j = SIZE - 1; j >= 0; j--) {
            for (int i = 0; i < SIZE; i++) {

                boolean registered = false;
                while (k < boardLayout.length() && !registered) {

                    switch (boardLayout.charAt(k)) {
                        case ('B'):
                            registered = true;
                            board[i][j] = B;
                            break;

                        case ('V'):
                            registered = true;
                            v.addPiece((byte) i, (byte) j);
                            board[i][j] = V;
                            break;

                        case ('H'):
                            registered = true;
                            h.addPiece((byte) i, (byte) j);
                            board[i][j] = H;
                            break;

                        case ('+'):
                            registered = true;
                            board[i][j] = O;
                            break;
                        default:
                            registered = false;
                    }
                    //     System.out.println("char: " +  boardLayout.charAt(k) +"\nregistered: "+registered+"\ni: "+i+"\nj: "+j+"\n\n");
                    k++;
                }
            }
        }
    }

    /**
     * Updates the boards state given a Move
     *
     * @param move       move object
     * @param playerType byte value H or V (2/3)
     */
    public void update(Move move, byte playerType) {

        switch (move.d) {
            case UP:
                //piece can move or went off the board
                if ((canMoveTo(move.i, move.j + 1)) || move.j + 1 == SIZE) {
                    board[move.i][move.j] = O;
                    board[move.i][move.j + 1] = playerType;
                    // move was illegal, this shouldn't happen
                } else {
                    System.out.println("ERROR: Illegal move");
                    System.exit(1);
                }
                break;

            case DOWN:
                //piece can move or went off the board
                if ((canMoveTo(move.i, move.j - 1)) || move.j - 1 == SIZE) {
                    board[move.i][move.j] = O;
                    board[move.i][move.j - 1] = playerType;
                    // move was illegal, this shouldn't happen
                } else {
                    System.out.println("ERROR: Illegal move");
                    System.exit(1);
                }
                break;

            case LEFT:
                //piece can move or went off the board
                if ((canMoveTo(move.i - 1, move.j)) || move.i - 1 == SIZE) {
                    board[move.i][move.j] = O;
                    board[move.i - 1][move.j] = playerType;
                    // move was illegal, this shouldn't happen
                } else {
                    System.out.println("ERROR: Illegal move");
                    System.exit(1);
                }
                break;

            case RIGHT:
                //piece can move or went off the board
                if ((canMoveTo(move.i + 1, move.j)) || move.i + 1 == SIZE) {
                    board[move.i][move.j] = O;
                    board[move.i + 1][move.j] = playerType;
                    // move was illegal, this shouldn't happen
                } else {
                    System.out.println("ERROR: Illegal move");
                    System.exit(1);
                }
                break;
        }
    }
/*      What are these for??


    @Override
    public String toString() {
        String string = "";
        int x, y;
        for (y = 0; y < SIZE; y++) {
            for (x = 0; x < SIZE; x++) {
               if (x+1 < SIZE) {
                   string += board[x][y] + " ";
               } else {
                   string += board[x][y] + "/n";
               }
            }
        }
        return string;
    }

    public char[][] toArray() {
        char[][] out = new char[SIZE][SIZE];
        int i, j;
        for (j = 0; j < SIZE; j++) {
            for (i = 0; i < SIZE; i++) {
                out[i][j] = board[i][j].type;
            }
        }
        return out;
    }
}
*/
}
